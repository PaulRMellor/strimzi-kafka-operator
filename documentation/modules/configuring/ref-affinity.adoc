// Module included in the following assemblies:
//
// assembly-scheduling.adoc

[id='affinity-{context}']
= Scheduling strategies

Kafka components can be scheduled onto Kubernetes nodes using affinity rules, tolerations, and topology constraints.  
These strategies help isolate workloads, optimize resource usage, and improve overall cluster performance.

The following scheduling techniques support different deployment goals:

Use pod anti-affinity to avoid critical applications sharing nodes::
Use pod anti-affinity to prevent critical applications from being scheduled on the same disk.  
In Kafka deployments, configure pod anti-affinity to ensure that Kafka brokers do not share nodes with other workloads, such as databases.

Use node affinity to schedule workloads onto specific nodes::
Kubernetes clusters often include nodes optimized for different workloads, such as CPU, memory, storage, or network.  
Node affinity enables scheduling Kafka components onto nodes that match specific labels, such as `beta.kubernetes.io/instance-type` or custom labels, to optimize performance and cost.

Use node affinity and tolerations for dedicated nodes::
Cluster administrators can taint nodes to exclude them from general scheduling.  
Kafka pods can be scheduled onto these dedicated nodes by configuring both node affinity and tolerations.  
This approach isolates Kafka from other workloads, reducing resource contention and improving stability.

To apply scheduling strategies, use `template.pod` properties in the `spec` section of the following resources

* `KafkaNodePool.spec.template.pod`
* `Kafka.spec.entityOperator.template.pod`
* `Kafka.spec.cruiseControl.template.pod`
* `KafkaConnect.spec.template.pod`
* `KafkaBridge.spec.template.pod`
* `KafkaMirrorMaker2.spec.template.pod`

Scheduling properties follow the Kubernetes specification.
