
[id='proc-generating-reassignment-json-files-{context}']
= Generating reassignment JSON files

[role="_abstract"]
This procedure describes how to generate a reassignment JSON file. Use the reassignment file with the `kafka-reassign-partitions.sh` tool to reassign partitions.

Secure the reassignment process using TLS. You'll need a Kafka cluster that uses TLS encryption and authentication.

.Prerequisites

* You have a running Cluster Operator.
* You have a a running Kafka cluster based on a `Kafka` resource configured with internal TLS authentication and encryption.
+
.Kafka configuration with TLS
[source,yaml,subs="attributes+"]
----
apiVersion: {KafkaApiVersion}
kind: Kafka
metadata:
  name: my-cluster
spec:
  kafka:
    # ...
    listeners:
      # ...
      - name: tls
        port: 9093
        type: internal
        tls: true <1>
        authentication:
          type: tls <2>
    # ...
----
<1> Enables TLS encryption for the internal listener.
<2> Listener authentication mechanism xref:assembly-securing-kafka-brokers-str[specified as mutual TLS].
* The running Kafka cluster contains a set of topics and partitions to reassign.
+
.Example topic configuration for `my-topic`
[source,yaml,subs="attributes+"]
----
apiVersion: {KafkaTopicApiVersion}
kind: KafkaTopic
metadata:
  name: my-topic
  labels:
    strimzi.io/cluster: my-cluster
spec:
  partitions: 10
  replicas: 3
  config:
    retention.ms: 7200000
    segment.bytes: 1073741824
    # ...
----
* You have a `KafkaUser` configured with ACL rules that specify permission to produce and consume topics from the Kafka brokers.
+
--
.Example Kafka user configuration with ACL rules for producing and consuming from `my-topic`
[source,yaml,subs="attributes+"]
----
apiVersion: {KafkaUserApiVersion}
kind: KafkaUser
metadata:
  name: my-user
  labels:
    strimzi.io/cluster: my-cluster
spec:
  authentication: <1>
    type: tls
  authorization:
    type: simple <2>
    acls:
      - resource:
          type: topic
          name: my-topic
          patternType: literal
        operation: Write
        host: "*"
      - resource:
          type: topic
          name: my-topic
          patternType: literal
        operation: Create
        host: "*"
      - resource:
          type: topic
          name: my-topic
          patternType: literal
        operation: Describe
        host: "*"
  # ...
----
<1> User authentication mechanism defined as mutual `tls`.
<2> Simple authorization and accompanying list of ACL rules.

NOTE: The minimum operation mapping for TLS access is `Describe`.
--

* You have tools to manage TLS certificates.
+
The steps in this procedure use the Keytool and OpenSSL TLS management tool and commands.

.Procedure

. Extract the public key certificate from the Secret of the Kafka cluster.
+
[source,shell,subs=+quotes]
kubectl get secret _CLUSTER-NAME_-cluster-ca-cert -o "jsonpath={.data['ca\.crt']}" | base64 -d > ca.crt
+
Replace _CLUSTER-NAME_ with the name of the Kafka cluster.
When you deploy Kafka using the `Kafka` resource, a Secret with the cluster CA certificates is created with the Kafka cluster name (`_CLUSTER-NAME_-cluster-ca-cert`).
For example, `my-cluster-cluster-ca-cert`.

. Create a truststore for TLS connection to the Kafka brokers and add the public key certificate of the Kafka cluster.
+
[source,shell,subs=+quotes]
keytool -keystore truststore.jks -alias rootca -storepass _TRUSTSTORE-PASSWORD_ -import -file ca.crt -noprompt
+
Replace _TRUSTSTORE-PASSWORD_ with your own password.

. Run a new interactive pod container using the Strimzi Kafka image to connect to a running Kafka broker.
+
[source,shell,subs="attributes+"]
----
kubectl run -ti --restart=Never --image={DockerKafkaImageCurrent} kafka-cli -- /bin/sh -c "sleep 3600"
----
+
The pod is named `kafka-cli`.

. Copy the truststore to the interactive pod container.
+
[source,shell]
kubectl cp truststore.jks kafka-cli:/tmp

. Extract the public key certificate from the Secret of the Kafka user that has permission to access the Kafka brokers.
+
[source,shell,subs=+quotes]
kubectl get secret _KAFKA-USER_ -o "jsonpath={.data['user\.crt']}" | base64 -d > user.crt
+
Replace _KAFKA-USER_ with the name of the Kafka user.
When you create a Kafka user using the `KafkaUser` resource, a Secret with the user CA certificates is created with the Kafka user name (`_CLUSTER-NAME_-clients-ca-cert`).
For example, `my-user-clients-ca-cert`.

. Extract the private key from the Secret of the Kafka user.
+
[source,shell,subs=+quotes]
kubectl get secret _KAFKA-USER_ -o "jsonpath={.data['user\.key']}" | base64 -d > user.key

. Create a keystore containing the public key certificate and private key of the kafka user.
+
[source,shell,subs=+quotes]
openssl pkcs12 -export -name user -passout pass:__KEYSTORE-PASSWORD__ -in user.crt -inkey user.key -out keystore.p12
+
Replace _KEYSTORE-PASSWORD_ with your own password.

. Import the keystore into a keystore in JKS format.
+
[source,shell,subs=+quotes]
----
keytool -importkeystore -alias user -srcstoretype PKCS12 -srckeystore keystore.p12 \
  -srcstorepass _KEYSTORE-PASSWORD_ \
  -destkeystore keystore.jks \
  -deststorepass _KEYSTORE-PASSWORD_
----
+
Replace _KEYSTORE-PASSWORD_ with your own passwords for the source and target keystores.

. Copy the keystore to the interactive pod container.
+
[source,shell]
kubectl cp keystore.jks kafka-cli:/tmp
+
The truststore and keystore allow the interactive pod container to connect to the Kafka broker using TLS.

. Create a `config.properties` file to specify the truststore and keystore used to authenticate connection to the Kafka cluster.
+
[source,properties,subs="+quotes,attributes"]
----
bootstrap.servers=__KAFKA-CLUSTER-NAME__-kafka-bootstrap:9093 <1>
security.protocol=SSL <2>
ssl.truststore.location=/tmp/truststore.jks <3>
ssl.truststore.password=__TRUSTSTORE-PASSWORD__ <4>
ssl.keystore.location=/tmp/keystore.jks <5>
ssl.keystore.password=__KEYSTORE-PASSWORD__ <6>
----
<1> The bootstrap server address to connect to the Kafka cluster. Use your own Kafka cluster name to replace `_KAFKA-CLUSTER-NAME_`.
<2> The security protocol option when using TLS for encryption.
<3> The truststore location contains the public key certificate (`ca.crt`) for the Kafka cluster.
<4> The password for accessing the truststore.
<5> The keystore location contains the public key certificate (`user.crt`) and the private key (`user.key`) for the Kafka user.
<6> The password for accessing the keystore.

. Copy the `config.properties` file to the interactive pod container.
+
[source,shell]
kubectl cp config.properties kafka-cli:/tmp/config.properties

. Prepare a JSON file named `topics.json` that specifies the topics to move.
+
Specify topic names as a comma-separated list.
+
.Example JSON file to reassign all the partitions of `topic-a` and `topic-b`
[source,json]
----
{
  "version": 1,
  "topics": [
    { "topic": "topic-a"},
    { "topic": "topic-b"}
  ]
}
----

. Copy the `_topics.json_` file to the interactive pod container.
+
[source,shell,subs=+quotes]
kubectl cp topics.json kafka-cli:/tmp/topics.json

. Start a shell process in the interactive pod container.
+
[source,shell,subs=+quotes]
kubectl exec -n _NAMESPACE_ -ti kafka-cli /bin/bash
+
Replace _NAMESPACE_ with the Kubernetes namespace where the pod is running.

. Use the `kafka-reassign-partitions.sh` command to generate the reassignment JSON.
+
.Example command to move all the partitions of `topic-a` and `topic-b` to brokers `0`, `1` and `2`.
[source,shell,subs=+quotes]
----
bin/kafka-reassign-partitions.sh --bootstrap-server my-cluster-kafka-bootstrap:9093 \
  --command-config /tmp/config.properties \
  --topics-to-move-json-file /tmp/topics.json \
  --broker-list 0,1,2 \
  --generate
----

[role="_additional-resources"]
.Additional resources

* xref:proc-config-kafka-{context}[Configuring Kafka]
* xref:proc-configuring-kafka-topic-{context}[Configuring a Kafka topic]
* xref:proc-configuring-kafka-user-{context}[Securing user access to Kafka]
