// Module included in the following assemblies:
//
// assembly-instrumenting-kafka-clients-tracers.adoc

[id='proc-instrumenting-producers-consumers-{context}']
= Instrumenting producers and consumers for tracing

[role="_abstract"]
Use a Decorator pattern or Interceptors to instrument your Java producer and consumer application code for tracing.
When instrumentation is added, you can record traces when messages are produced or retrieved from a topic.

The OpenTracing and OpenTelemetry instrumentation projects provide classes that support instrumentation of producers and consumers.
You enable instrumentation in producer and consumer applications by adding the tracing JARs as a dependency to your project.

Decorator instrumentation:: For Decorator instrumentation, create a modified producer or consumer instance for tracing.
Interceptor instrumentation:: For Interceptor instrumentation, add the tracing capability to the consumer or producer configuration.
You do this by adding the `TracingProducerInterceptor` and `TracingConsumerInterceptor` instrumentation classes.

.Procedure

. Add the Maven dependencies for distributed tracing to the producer or consumer's `pom.xml` file.
+
--
.Dependencies for OpenTracing
[source,xml,subs="attributes+"]
----
<dependency>
  <groupId>io.opentracing.contrib</groupId>
  <artifactId>opentracing-kafka-client</artifactId>
  <version>{OpenTracingKafkaClient}</version>
</dependency>
----
.Dependencies for OpenTelemetry
[source,xml,subs="attributes+"]
----
<dependency>
  <groupId>io.opentelemetry</groupId>
  <artifactId>opentelemetry-sdk-extension-autoconfigure</artifactId>
  <version>{OpenTelemetryVersion}</version>
</dependency>
<dependency>
  <groupId>io.opentelemetry</groupId>
  <artifactId>opentelemetry-semconv</artifactId>
  <version>{OpenTelemetryVersion}</version>
</dependency>
<dependency>
  <groupId>io.opentelemetry</groupId>
  <artifactId>opentelemetry-sdk-trace</artifactId>
  <version>{OpenTelemetryVersionStable}</version>
</dependency>
<dependency>
  <groupId>io.opentelemetry.instrumentation</groupId>
  <artifactId>opentelemetry-kafka-clients-{OpenTelemetryKafkaClient}</artifactId>
  <version>{OpenTelemetryVersion}</version>
</dependency>
<dependency>
  <groupId>io.opentelemetry.instrumentation</groupId>
  <artifactId>opentelemetry-kafka-clients-common</artifactId>
  <version>{OpenTelemetryVersion}</version>
</dependency>
<dependency>
  <groupId>io.opentelemetry</groupId>
  <artifactId>opentelemetry-exporter-jaeger</artifactId>
  <version>{OpenTelemetryVersionStable}</version>
</dependency>
<dependency>
  <groupId>io.grpc</groupId>
  <artifactId>grpc-netty-shaded</artifactId>
  <version>{OpenTelemetryGrpcVersion}</version>
</dependency>
----
--

. Instrument your client application code using either a Decorator pattern or Interceptors.

* The Decorator pattern instrumentation is different for OpenTracing and OpenTelemetry,
but in both cases you add tracing to an instance of a producer or consumer.
+
--
.Example Decorator instrumentation for OpenTracing
[source,java,subs=attributes+]
----
// Create an instance of the KafkaProducer:
KafkaProducer<Integer, String> producer = new KafkaProducer<>(senderProps);

// Create an instance of the TracingKafkaProducer:
TracingKafkaProducer<Integer, String> tracingProducer = new TracingKafkaProducer<>(producer,
        tracer);

// Send:
tracingProducer.send(...);

// Create an instance of the KafkaConsumer:
KafkaConsumer<Integer, String> consumer = new KafkaConsumer<>(consumerProps);

// Create an instance of the TracingKafkaConsumer:
TracingKafkaConsumer<Integer, String> tracingConsumer = new TracingKafkaConsumer<>(consumer,
        tracer);

// Subscribe:
tracingConsumer.subscribe(Collections.singletonList("mytopic"));

// Get messages:
ConsumerRecords<Integer, String> records = tracingConsumer.poll(1000);

// Retrieve SpanContext from polled record (consumer side):
ConsumerRecord<Integer, String> record = ...
SpanContext spanContext = TracingKafkaUtils.extractSpanContext(record.headers(), tracer);
----

.Example Decorator instrumentation for OpenTelemetry
[source,java,subs=attributes+]
----
// Create an instance of the KafkaProducer with tracing:
Producer<String, String> op = new KafkaProducer<>(
            configs,
            new StringSerializer(),
            new StringSerializer()
        );
        Producer<String, String> producer = tracing.wrap(op);

// Send:
producer.send(...);

// Create an instance of the KafkaConsumer with tracing:
Consumer<String, String> oc = new KafkaConsumer<>(
            configs,
            new StringDeserializer(),
            new StringDeserializer()
        );
        Consumer<String, String> consumer = tracing.wrap(oc);

// Subscribe:
consumer.subscribe(Collections.singleton("mytopic"));

// Get messages:
ConsumerRecords<Integer, String> records = consumer.poll(1000);
----
--

* For Interceptors, instrumenting is the same for OpenTracing and OpenTelemetry.
+
.Example Interceptor instrumentation
[source,java,subs=attributes+]
----
// Register the tracer with GlobalTracer:
GlobalTracer.register(tracer);

// Add the TracingProducerInterceptor to the sender properties:
senderProps.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG,
          TracingProducerInterceptor.class.getName());

// Create an instance of the KafkaProducer:
KafkaProducer<Integer, String> producer = new KafkaProducer<>(senderProps);

// Send:
producer.send(...);

// Add the TracingConsumerInterceptor to the consumer properties:
consumerProps.put(ConsumerConfig.INTERCEPTOR_CLASSES_CONFIG,
          TracingConsumerInterceptor.class.getName());

// Create an instance of the KafkaConsumer:
KafkaConsumer<Integer, String> consumer = new KafkaConsumer<>(consumerProps);

// Subscribe:
consumer.subscribe(Collections.singletonList("messages"));

// Get messages:
ConsumerRecords<Integer, String> records = consumer.poll(1000);

// Retrieve the SpanContext from a polled message (consumer side):
ConsumerRecord<Integer, String> record = ...
SpanContext spanContext = TracingKafkaUtils.extractSpanContext(record.headers(), tracer);
----

== Custom span names for OpenTracing Decorator instrumentation

A __span__ is a logical unit of work in Jaeger, with an operation name, start time, and duration.

To use a Decorator pattern to instrument your producer and consumer applications, define custom span names by passing a `BiFunction` object as an additional argument when creating the `TracingKafkaProducer` and `TracingKafkaConsumer` objects.
The OpenTracing Apache Kafka Client Instrumentation library includes several built-in span names.

.Example custom span names to instrument client application code in a Decorator pattern
[source,java,subs=attributes+]
----
// Create a BiFunction for the KafkaProducer that operates on (String operationName, ProducerRecord consumerRecord) and returns a String to be used as the name:

BiFunction<String, ProducerRecord, String> producerSpanNameProvider =
    (operationName, producerRecord) -> "CUSTOM_PRODUCER_NAME";

// Create an instance of the KafkaProducer:
KafkaProducer<Integer, String> producer = new KafkaProducer<>(senderProps);

// Create an instance of the TracingKafkaProducer
TracingKafkaProducer<Integer, String> tracingProducer = new TracingKafkaProducer<>(producer,
        tracer,
        producerSpanNameProvider);

// Spans created by the tracingProducer will now have "CUSTOM_PRODUCER_NAME" as the span name.

// Create a BiFunction for the KafkaConsumer that operates on (String operationName, ConsumerRecord consumerRecord) and returns a String to be used as the name:

BiFunction<String, ConsumerRecord, String> consumerSpanNameProvider =
    (operationName, consumerRecord) -> operationName.toUpperCase();

// Create an instance of the KafkaConsumer:
KafkaConsumer<Integer, String> consumer = new KafkaConsumer<>(consumerProps);

// Create an instance of the TracingKafkaConsumer, passing in the consumerSpanNameProvider BiFunction:

TracingKafkaConsumer<Integer, String> tracingConsumer = new TracingKafkaConsumer<>(consumer,
        tracer,
        consumerSpanNameProvider);

// Spans created by the tracingConsumer will have the operation name as the span name, in upper-case.
// "receive" -> "RECEIVE"
----

== Built-in span names for OpenTracing Decorator instrumentation

When defining custom span names, you can use the following `BiFunctions` in the `ClientSpanNameProvider` class.
If no `spanNameProvider` is specified, `CONSUMER_OPERATION_NAME` and `PRODUCER_OPERATION_NAME` are used.

.BiFunctions for defining custom span names
[%autowidth,cols="2*",options="header",stripes="none",separator=¦]
|===

¦BiFunction
¦Description

m¦CONSUMER_OPERATION_NAME, PRODUCER_OPERATION_NAME
¦Returns the `operationName` as the span name: "receive" for consumers and "send" for producers.

m¦CONSUMER_PREFIXED_OPERATION_NAME(String prefix), PRODUCER_PREFIXED_OPERATION_NAME(String prefix)
¦Returns a String concatenation of `prefix` and `operationName`.

m¦CONSUMER_TOPIC, PRODUCER_TOPIC
¦Returns the name of the topic that the message was sent to or retrieved from in the format `(record.topic())`.

m¦PREFIXED_CONSUMER_TOPIC(String prefix), PREFIXED_PRODUCER_TOPIC(String prefix)
¦Returns a String concatenation of `prefix` and the topic name in the format `(record.topic())`.

m¦CONSUMER_OPERATION_NAME_TOPIC, PRODUCER_OPERATION_NAME_TOPIC
¦Returns the operation name and the topic name: `"operationName - record.topic()"`.

m¦CONSUMER_PREFIXED_OPERATION_NAME_TOPIC(String prefix), PRODUCER_PREFIXED_OPERATION_NAME_TOPIC(String prefix)
¦Returns a String concatenation of `prefix` and `"operationName - record.topic()"`.

|===

== Attribute extraction for OpenTelemetry instrumentation

Span names cannot be changed with OpenTelemetry.
Instead, you can use the OpenTelemtery `AttributesBuilder` in you client application code to extract additional tags and attributes.

.Example code to extract attributes
[source,java,subs=attributes+]
----
//Start and end of attribute extraction for a producer:
private static class ProducerAttribExtractor implements AttributesExtractor<ProducerRecord<?, ?>, Void> {
    @Override
    public void onStart(AttributesBuilder attributes, ProducerRecord<?, ?> producerRecord) {
            set(attributes, AttributeKey.stringKey("prod_start"), "prod1");
    }

    @Override
    public void onEnd(AttributesBuilder attributes, ProducerRecord<?, ?> producerRecord, @Nullable Void unused, @Nullable Throwable error) {
        set(attributes, AttributeKey.stringKey("prod_end"), "prod2");
    }
}
//Start and end of attribute extraction for a consumer:
private static class ConsumerAttribExtractor implements AttributesExtractor<ConsumerRecord<?, ?>, Void> {
    @Override
    public void onStart(AttributesBuilder attributes, ConsumerRecord<?, ?> producerRecord) {
        set(attributes, AttributeKey.stringKey("con_start"), "con1");
    }

    @Override
    public void onEnd(AttributesBuilder attributes, ConsumerRecord<?, ?> producerRecord, @Nullable Void unused, @Nullable Throwable error) {
        set(attributes, AttributeKey.stringKey("con_end"), "con2");
    }
}
//Extract the attributes:
public static void main(String[] args) throws Exception {
    Map<String, Object> configs = new HashMap<>(Collections.singletonMap(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092"));

    System.setProperty("otel.traces.exporter", "jaeger");
    System.setProperty("otel.service.name", "myapp1");
    KafkaTracing tracing = KafkaTracing.newBuilder(GlobalOpenTelemetry.get())
        .addProducerAttributesExtractors(new ProducerAttribExtractor())
        .addConsumerAttributesExtractors(new ConsumerAttribExtractor())
        .build();
----
