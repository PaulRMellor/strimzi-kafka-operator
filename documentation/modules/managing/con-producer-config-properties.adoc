// This module is included in the following files:
//
// assembly-client-config.adoc

[id='con-producer-config-properties-{context}']
= Kafka producer configuration tuning

Use a minimum producer configuration with optional properties that are tailored to specific uses cases.

== Minimum producer configuration

Connection and serializer properties are required for every producer.
Generally, it is good practice to add a client id for tracking, and use compression on the producer to reduce batch sizes in requests.

[source,shell,subs="+quotes,attributes"]
----
# ...
bootstrap.servers=localhost:9092 <1>
key.serializer=org.apache.kafka.common.serialization.StringSerializer <2>
value.serializer=org.apache.kafka.common.serialization.StringSerializer <3>
client.id=my-client <4>
compression.type=gzip <5>
# ...
----
<1> (Required) Tells the producer to connect to a Kafka cluster using a _host:port_ bootstrap server address for a Kafka broker.
The producer uses the address to discover and connect to all brokers in the cluster.
Use a comma-separated list to specify more than one address in case a server is down.
<2> (Required) Key serializer to put the key part of the messages it sends to a broker topic into the correct format.
<3> (Required) Key serializer to put the value part of the messages it sends to a broker topic into the correct format.
<4> (Optional) The logical name for the client, which is used in logs and metrics to identify the source of a request.
<5> (Optional) The codec for compressing messages, which are stored in compressed format and then decompressed when reaching a consumer.
Compression is useful for improving throughput and reducing the load on storage, but might not be appropriate for low latency applications.

== Durability

You can apply greater data durability, to minimize the likelihood that messages are lost. using message delivery acknowledgments.

----
# ...
acks=all <1>
# ...
----
<1> Specifying `acks=all` forces a partition leader to replicate messages to all followers before
acknowledging that the message request was successfully received.
Because of the additional checks, `acks=all` increases latency.

In addition to using `acks=all`, configure the topics receiving the messages to have more than one in-sync replica.
A typical starting point is to have a topic replication factor of 3, with two in-sync replicas on other brokers.
The producer can continue unaffected if a broker is unavailable as long as an in-sync replica is available.

.Topic configuration to support `acks=all`
----
# ...
offsets.topic.replication.factor=3 <1>
min.insync.replicas=2 <2>
# ...
----
<1> Try a replication factor of `3` at first, which is the default.
<2> Use `2` in-sync replicas. The default is `1`.

== Ordered delivery

Idempotent producers do not introduce duplicates as messages are delivered exactly once.
IDs and sequence numbers are assigned to messages to ensure the order of delivery, even in the event of failure.
If you are using `acks=all` for data consistency, enabling idempotency makes sense for ordered delivery.

.Ordered delivery with idempotency
----
# ...
enable.idempotence=true <1>
max.in.flight.requests.per.connection=5 <2>
acks=all <3>
retries=2147483647 <4>
# ...
----
<1> Set to `true`.
<2> Specify the number of allowed in-flight requests to a maximum of 5.
<3> Set to `all`.
<4> Set the number of attempts to resend a failed message request.
The default (`2147483647`) is high because retries are sent at very short intervals.

If the performance cost is too great, and you are not using `acks=all`,
set the number of in-flight (unacknowledged) requests to 1 to preserve ordering.
Otherwise, a situation is possible where _Message-A_ fails only to succeed after _Message-B_ was already written to the broker.

.Ordered delivery without idempotency
----
# ...
enable.idempotence=false <1>
max.in.flight.requests.per.connection=1 <2>
retries=2147483647
# ...
----
<1> Set to `false`.
<2> Set the number of in-flight requests to exactly `1`.

== Reliability

Use transactions with an idempotent producer to ensure the reliability of transactions.

Idempotence is useful for exactly once writes from a single partition.
Transactions, when used with idempotence, allow exactly once writes across multiple partitions.

Transactions guarantee that messages using the same transactional ID are produced once,
and must _all_ be successfully written before a new transaction is allowed.

----
# ...
enable.idempotence=true
max.in.flight.requests.per.connection=5
acks=all
retries=2147483647
transactional.id=_UNIQUE-ID_ <1>
transaction.timeout.ms=900000 <2>
# ...
----
<1> Specify a unique transactional ID.
<2> Set the maximum allowed time for transactions in milliseconds before a timeout error is returned.
The default is `900000` or 15 minutes.


== Lower latency

Producers scaled to produce a high rate of requests might cause queues in the Kafka cluster and increase latency.

Use a buffer and add a small delay to reduce the number of requests to topics from producers that are not contributing a large number of messages.
You can set the delay in conjunction with a maximum batch size, so the delay only applies if the batch size is not reached earlier.

NOTE: If the system fails, there is a risk of unsent data in the buffer being lost.

----
# ...
linger.ms=1 <1>
batch.size=16384 <2>
buffer.memory=33554432 <3>
# ...
----
<1> The `linger` property adds a delay in milliseconds so that larger batches of messages are accumulated and sent in a request. The defaullt is `0'.`
<2> If a maximum `batch.size` in bytes is used, a request is sent when the maximum is reached.
Adding the delay allows batches to accumulate messages up to the batch size.
<3> The buffer size must be at least as big as the batch size, and be able to accommodate buffering, compression and in-flight requests.

== Increased throughput

Improve throughput of your message requests by adjusting the maximum time to wait before a message is delivered and completes a send request.
If you have a large number of topics to write to, you can also lower the time it takes to pick up topic metadata changes and reduce the time to discover new brokers or partitions.

You can also direct messages to a specified partition by writing a custom partitioner to replace the default.

----
# ...
delivery.timeout.ms=120000 <1>
metadata.max.age.ms=300000 <2>
partitioner.class=my-custom-partitioner <3>

# ...
----
<1> The maximum time in milliseconds to wait for a complete send request. You can set the value to `MAX_LONG` to delegate to Kafka an indefinite number of retries.
The default is `120000` or 2 minutes.
<2> Time in milliseconds before the next refresh of topic metadata. The default is `300000` or 5 minutes.
<3> Specify the class name of the custom partitioner.
